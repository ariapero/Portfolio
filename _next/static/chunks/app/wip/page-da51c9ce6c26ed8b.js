(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[189],{407:(e,n,t)=>{Promise.resolve().then(t.bind(t,8059))},8059:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var r=t(5155),i=t(7396),o=t(2115);let a=()=>{let e=(0,o.useRef)(null);return(0,o.useEffect)(()=>{let n,t,r,i;let o=e.current;if(!o)return;let a=o.getContext("webgl2");if(!a)return;let s=window.devicePixelRatio,c=[],l=()=>{let{innerWidth:e,innerHeight:n}=window;o.width=e*s,o.height=n*s,a.viewport(0,0,e*s,n*s)},f=(e,n)=>{a.shaderSource(e,n),a.compileShader(e),a.getShaderParameter(e,a.COMPILE_STATUS)||console.error(a.getShaderInfoLog(e))},d=e=>{a.clearColor(0,0,0,1),a.clear(a.COLOR_BUFFER_BIT),a.useProgram(r),a.bindBuffer(a.ARRAY_BUFFER,t),a.uniform1f(n,.001*e),a.uniform2f(i,o.width,o.height),a.drawArrays(a.TRIANGLES,0,.5*c.length)},p=e=>{d(e),requestAnimationFrame(p)};return(()=>{let e=a.createShader(a.VERTEX_SHADER),o=a.createShader(a.FRAGMENT_SHADER);if(!e||!o||!(r=a.createProgram()))return;f(e,"#version 300 es\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n    \n    in vec2 position;\n    \n    void main(void) {\n        gl_Position = vec4(position, 0., 1.);\n    }\n    "),f(o,"#version 300 es\n    /*********\n    * made by Matthias Hurrle (@atzedent)\n    */\n    \n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n    \n    out vec4 fragColor;\n    \n    uniform vec2 resolution;\n    uniform float time;\n    \n    #define S smoothstep\n    #define T .112358+time\n    \n    float rnd(vec2 p) {\n      return fract(\n        sin(\n          dot(\n            p,\n            vec2(12.9898, 78.233)\n          )\n        )*43758.5453123\n      );\n    }\n    \n    float noise(vec2 p) {\n      vec2 f=fract(p), i=floor(p);\n      float\n      a=rnd(i),\n      b=rnd(i+vec2(1,0)),\n      c=rnd(i+vec2(0,1)),\n      d=rnd(i+vec2(1,1));\n    \n      vec2 u = f*f*(3.-2.*f);\n    \n      return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.y*u.x;\n    }\n    \n    void main(void) {\n      vec2 uv = (\n        gl_FragCoord.xy -.5 * resolution.xy\n      )/min(resolution.x, resolution.y);\n\n      float t = T*.1;\n      vec3 col = vec3(0);\n      vec2 p = vec2(0);\n      p.x = noise(uv+vec2(0,1));\n      p.y = noise(uv+vec2(1,0));\n\n      p = 8.*(\n        vec2(\n          sin(t),\n          -cos(t)\n        )*.15-p\n      );\n\n      float s = .35;\n      \n      for(float i=.0;i<6.;i++) {\n        p.x += s*sin(2.*t-i*1.5*p.y)+t;\n        p.y += s*cos(2.*t+i*1.5*p.x)-t;\n      }\n\n      col+= sin(t+p.x+p.y);\n      col = pow(S(vec3(0),vec3(1),col), vec3(.4));\n\n      // Define our two color schemes\n      vec3 greenWithWhite = mix(vec3(0.0, 0.3, 0.2), vec3(0.0), col);\n      vec3 whiteWithGreen = mix(vec3(0.0), vec3(0.0, 0.3, 0.2), col);\n\n      float stp = 2.,\n            prog = T * .2,\n            anim = floor(mod(prog - .5, stp));\n\n      if (anim == .0) {\n        prog -= length(uv) * .2;\n      } else {\n        prog -= min(abs(uv.x), abs(uv.y)) * .2;\n      }\n      \n      float scene = floor(mod(prog, stp));\n      \n      // Switch between color schemes instead of inverting\n      if (scene == .0) {\n        col = greenWithWhite;\n      } else {\n        col = whiteWithGreen;\n      }\n\n      fragColor = vec4(col, 1);\n    }\n    "),a.attachShader(r,e),a.attachShader(r,o),a.linkProgram(r),a.getProgramParameter(r,a.LINK_STATUS)||console.error(a.getProgramInfoLog(r)),c=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1],t=a.createBuffer(),a.bindBuffer(a.ARRAY_BUFFER,t),a.bufferData(a.ARRAY_BUFFER,new Float32Array(c),a.STATIC_DRAW);let s=a.getAttribLocation(r,"position");a.enableVertexAttribArray(s),a.vertexAttribPointer(s,2,a.FLOAT,!1,0,0),n=a.getUniformLocation(r,"time"),i=a.getUniformLocation(r,"resolution")})(),l(),p(0),window.addEventListener("resize",l),()=>{window.removeEventListener("resize",l)}},[]),(0,r.jsx)("canvas",{ref:e,style:{position:"fixed",top:0,left:0,width:"100%",height:"100%",zIndex:-1}})};function s(){return(0,r.jsxs)("div",{className:"min-h-screen p-8 relative",children:[(0,r.jsx)(a,{}),(0,r.jsx)("div",{className:"max-w-6xl mx-auto relative z-10",children:(0,r.jsx)("header",{className:"mb-12",children:(0,r.jsxs)("h1",{className:"h-screen flex justify-center items-center flex-col text-center text-white font-inter transform transition-transform duration-[1700ms] ease-cubic-bezier",children:[(0,r.jsx)("span",{className:"inline-block whitespace-nowrap font-grand text-4xl",style:{textShadow:"2px 2px 4px rgba(0,0,0, 0.5)"},children:"Oops! This page still needs some work."}),(0,r.jsxs)("span",{className:"inline-block whitespace-nowrap mt-4 font-zen text-xl",style:{textShadow:"2px 2px 4px rgba(0,0,0, 0.5)"},children:["Feel free to reference"," ",(0,r.jsx)(i.default,{href:"https://ariapero.myportfolio.com/",target:"_blank",rel:"noopener noreferrer",className:"text-white underline hover:opacity-80 inline",children:"my previous portfolio site"})," ","for more content."]})]})})})]})}},7396:(e,n,t)=>{"use strict";t.d(n,{default:()=>i.a});var r=t(4839),i=t.n(r)}},e=>{var n=n=>e(e.s=n);e.O(0,[839,441,517,358],()=>n(407)),_N_E=e.O()}]);